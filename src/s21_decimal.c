#include "s21_decimal.h"


int s21_is_equal(s21_decimal a, s21_decimal b) { return s21_cmp(&a, &b) == 0; }

/**
 * Функция s21_from_int_to_decimal
 * 
 * Преобразует целое число (int) в структуру s21_decimal.
 * 
 * @param src Целое число, которое необходимо преобразовать.
 * @param dst Указатель на структуру s21_decimal, куда будет записан результат.
 * @return Функция возвращает 0, если преобразование выполнено успешно, и 1, если произошла ошибка (например, если указатель dst равен NULL).
 * 
 * Примечания:
 * 1. Функция обнуляет все биты структуры s21_decimal, чтобы гарантировать отсутствие "мусора" в старших битах.
 * 2. Функция учитывает знак числа и устанавливает его в структуре.
 */
int s21_from_int_to_decimal(int src, s21_decimal *dst) {
    // Переменная flag используется для хранения кода возврата.
    int flag = 0;

    // Проверяем, что указатель на структуру s21_decimal не равен NULL.
    if (dst) {
        // Обнуляем все элементы массива bits, чтобы очистить структуру.
        for (int i = 0; i < 4; ++i) 
            dst->bits[i] = 0;

        // Определяем знак исходного числа: 0 для положительных чисел и 1 для отрицательных.
        int sign = src < 0;

        // Устанавливаем знак в структуре s21_decimal.
        s21_set_sign(dst, sign);

        // Если число отрицательное, делаем его положительным для дальнейшего использования.
        // Записываем абсолютное значение числа в первый элемент массива bits.
        dst->bits[0] = (sign ? -src : src);
    } else {
        // Если указатель dst равен NULL, устанавливаем flag в 1, что указывает на ошибку.
        flag = 1;
    }

    // Возвращаем flag: 0 - успешное выполнение, 1 - ошибка.
    return flag;
}


/**
 * Функция s21_from_float_to_decimal
 * 
 * Преобразует число с плавающей запятой (float) в структуру s21_decimal.
 * 
 * @param src Число с плавающей запятой, которое необходимо преобразовать.
 * @param dst Указатель на структуру s21_decimal, куда будет записан результат.
 * @return Функция возвращает 0, если преобразование выполнено успешно, и 1, если произошла ошибка (например, если указатель dst равен NULL или число выходит за допустимые пределы).
 * 
 * Примечания:
 * 1. Функция проверяет указатель dst на NULL. Если он равен NULL, возвращается ошибка.
 * 2. Обнуляет все биты структуры s21_decimal, чтобы гарантировать отсутствие "мусора" в старших битах.
 * 3. Функция обрабатывает случаи, когда src является бесконечностью, нечисловым значением (NaN), слишком большим или слишком маленьким числом, которое невозможно преобразовать. В этих случаях функция возвращает ошибку.
 * 4. Если src равно 0.0, устанавливается соответствующий знак в структуре dst.
 * 5. Для обработки значений, отличных от 0.0, функция преобразует число в строковое представление с научной нотацией (например, "1.234567E+03") с точностью до 6 знаков после запятой.
 * 6. Полученная строка анализируется для извлечения экспоненты. Если экспонента меньше или равна -23, пересчитывается строка с учетом более высокой точности.
 * 7. Функция s21_float_string_to_decimal преобразует строковое представление числа в формат s21_decimal.
 * 8. Если исходное число отрицательное, устанавливается соответствующий знак в структуре s21_decimal.
 */
int s21_from_float_to_decimal(float src, s21_decimal *dst) {
    // Переменная flag используется для хранения кода возврата.
    int flag = 0;

    // Проверяем, что указатель на структуру s21_decimal не равен NULL.
    if (!dst)
        flag = 1;
    else {
        // Обнуляем все элементы массива bits, чтобы очистить структуру.
        for (int i = 0; i < 4; ++i) 
            dst->bits[i] = 0;

        // Проверяем, является ли число бесконечностью, NaN, слишком большим или слишком маленьким.
        if (isinf(src) || isnan(src) || fabsf(src) > MAX_FLOAT_TO_CONVERT ||
            fabsf(src) < MIN_FLOAT_TO_CONVERT)
            flag = 1;
        else if (src == 0.0) {
            // Если число равно 0.0, просто устанавливаем знак.
            s21_set_sign(dst, signbit(src));
        } else {
            // Преобразуем число в строку в научной нотации с точностью до 6 знаков после запятой.
            char flt[16];
            sprintf(flt, "%.6E", fabsf(src));

            // Извлекаем экспоненту из строки.
            int exp = s21_get_exp_from_string(flt);

            // Если экспонента слишком мала (меньше или равна -23), пересчитываем строку с большей точностью.
            if (exp <= -23) {
                int float_precision = exp + 28;
                sprintf(flt, "%.*E", float_precision, fabsf(src));
            }

            // Преобразуем строку в формат s21_decimal.
            s21_float_string_to_decimal(flt, dst);

            // Если исходное число отрицательное, устанавливаем знак в структуре.
            if (src < 0) {
                s21_set_sign(dst, 1);
            }
        }
    }

    // Возвращаем flag: 0 - успешное выполнение, 1 - ошибка.
    return flag;
}

/**
 * Функция s21_from_decimal_to_float
 * 
 * Преобразует число в формате s21_decimal в число с плавающей запятой (float).
 * 
 * @param src Число в формате s21_decimal, которое необходимо преобразовать.
 * @param dst Указатель на переменную типа float, куда будет записан результат.
 * @return Функция возвращает 0, если преобразование выполнено успешно, и 1, если произошла ошибка (например, если указатель dst равен NULL).
 * 
 * Примечания:
 * 1. Функция проверяет указатель dst на NULL. Если он равен NULL, возвращается ошибка.
 * 2. Обрабатывается случай, когда src равно нулю. В этом случае результат равен 0.0 или -0.0, в зависимости от знака.
 * 3. Если src не равно нулю, функция преобразует его в число с плавающей запятой, начиная с инициализации результата нулем.
 * 4. Знак числа определяется функцией s21_get_sign.
 * 5. Порядок числа (десятичный экспонент) извлекается с помощью функции s21_get_pow.
 * 6. Внутреннее представление числа s21_decimal анализируется бит за битом для вычисления значения в формате double.
 * 7. Каждый установленный бит добавляет к результату соответствующую степень двойки.
 * 8. После этого результат делится на 10 в степени, равной порядку числа, чтобы учесть десятичные разряды.
 * 9. Если исходное число было отрицательным, результат умножается на -1.
 * 10. Окончательный результат преобразуется в float и записывается в переменную dst.
 */
int s21_from_decimal_to_float(s21_decimal src, float *dst) {
    // Переменная flag используется для хранения кода возврата.
    int flag = 0;

    // Проверяем, что указатель на переменную float не равен NULL.
    if (!dst)
        flag = 1;
    else {
        // Переменная res используется для накопления результата в формате double.
        double res;

        // Определяем нулевое значение в формате s21_decimal.
        s21_decimal zero = {{0}};

        // Проверяем, равно ли число нулю.
        if (s21_is_equal(src, zero))
            // Если число равно нулю, результат 0.0 или -0.0 в зависимости от знака.
            res = s21_get_sign(&src) ? -0.0 : 0.0;
        else {
            // Если число не равно нулю, начинаем преобразование.
            res = 0.0;

            // Получаем знак числа (0 - положительное, 1 - отрицательное).
            int sign = s21_get_sign(&src);

            // Получаем порядок числа (экспоненту в десятичной системе).
            int power = s21_get_pow(&src);

            // Проходим по всем битам числа в трех младших словах (bits[0], bits[1], bits[2]).
            for (int i = 0; i <= 2; i++) {
                for (int j = 0; j <= 31; j++) {
                    // Если бит установлен, добавляем соответствующую степень двойки к результату.
                    if (s21_bit(src.bits[i], j) != 0) {
                        res += pow(2.0, i * 32 + j);
                    }
                }
            }

            // Корректируем результат на порядок числа, деля на 10 в степени power.
            double power_ten = pow(10, power);
            res /= power_ten;

            // Если исходное число было отрицательным, умножаем результат на -1.
            if (sign == 1) {
                res *= -1.0;
            }
        }

        // Преобразуем результат в float и записываем его в dst.
        *dst = (float)res;
    }

    // Возвращаем flag: 0 - успешное выполнение, 1 - ошибка.
    return flag;
}
/**
 * Функция s21_from_decimal_to_int
 * 
 * Преобразует число в формате s21_decimal в целое число (int).
 * 
 * @param src Число в формате s21_decimal, которое необходимо преобразовать.
 * @param dst Указатель на переменную типа int, куда будет записан результат.
 * @return Функция возвращает 0, если преобразование выполнено успешно, и 1, если произошла ошибка (например, если указатель dst равен NULL или значение выходит за пределы диапазона int).
 * 
 * Примечания:
 * 1. Функция проверяет указатель dst на NULL. Если он равен NULL, возвращается ошибка.
 * 2. Используется функция s21_truncate для усечения дробной части числа в формате s21_decimal, поскольку целое число не может содержать дробную часть.
 * 3. Функция определяет минимально и максимально допустимые значения для типа int в формате s21_decimal (min и max).
 * 4. Если src меньше min или больше max, возвращается ошибка, так как значение не может быть преобразовано в int.
 * 5. Если src находится в допустимом диапазоне, значение записывается в dst с учетом знака (определяется функцией s21_get_sign).
 */
int s21_from_decimal_to_int(s21_decimal src, int *dst) {
    // Переменная flag используется для хранения кода возврата.
    int flag = 0;

    // Проверяем, что указатель на переменную int не равен NULL.
    if (!dst)
        flag = 1;
    else {
        // Усечение дробной части числа в формате s21_decimal.
        s21_truncate(src, &src);

        // Определение минимального и максимального значений для типа int в формате s21_decimal.
        s21_decimal min = {{-2147483648, 0, 0, NEGATIVE}};
        s21_decimal max = {{2147483647, 0, 0, POSITIVE}};

        // Проверка, входит ли число src в диапазон допустимых значений.
        if (s21_is_less(src, min) || s21_is_greater(src, max))
            flag = 1;  // Если значение выходит за пределы диапазона, устанавливаем флаг ошибки.
        else
            // Преобразуем число в int с учетом знака и записываем результат в dst.
            *dst = s21_get_sign(&src) ? -src.bits[0] : src.bits[0];
    }

    // Возвращаем flag: 0 - успешное выполнение, 1 - ошибка.
    return flag;
}
